
import { Transaction } from '../types';

export const exportToCSV = (transactions: Transaction[]) => {
  const headers = ['id', 'date', 'description', 'amount', 'type', 'category'];
  
  const csvRows = [
    headers.join(','),
    ...transactions.map(t => {
      // Escape quotes in description and handle commas
      const escapedDesc = `"${t.description.replace(/"/g, '""')}"`;
      return [
        t.id,
        t.date,
        escapedDesc,
        t.amount,
        t.type,
        t.category
      ].join(',');
    })
  ];

  const csvString = csvRows.join('\n');
  const blob = new Blob([csvString], { type: 'text/csv' });
  const url = window.URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.setAttribute('hidden', '');
  a.setAttribute('href', url);
  a.setAttribute('download', `transactions_${new Date().toISOString().split('T')[0]}.csv`);
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
};

export const parseCSV = (file: File): Promise<Transaction[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (event) => {
      const text = event.target?.result as string;
      if (!text) {
        reject('Empty file');
        return;
      }

      try {
        const rows = text.split('\n');
        // Simple CSV parser assuming standard format generated by export
        // Skip header
        const transactions: Transaction[] = [];
        
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i].trim();
          if (!row) continue;

          // Regex to handle comma splitting while respecting quotes
          const matches = row.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g);
          // Fallback split if regex fails or simple CSV
          const cols = matches 
            ? matches.map(m => m.replace(/^"|"$/g, '').replace(/""/g, '"')) 
            : row.split(',');

          if (cols.length >= 6) {
             // Cols: id, date, description, amount, type, category
             transactions.push({
               id: cols[0] || Date.now().toString(),
               date: cols[1],
               description: cols[2],
               amount: parseFloat(cols[3]),
               type: cols[4] as 'income' | 'expense',
               category: cols[5]
             });
          }
        }
        resolve(transactions);
      } catch (e) {
        reject(e);
      }
    };

    reader.onerror = () => reject('Error reading file');
    reader.readAsText(file);
  });
};
